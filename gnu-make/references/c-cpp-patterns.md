# C/C++ Patterns

## Table of Contents
- [Canonical C Project Makefile](#canonical-c-project-makefile)
- [Auto-Dependency Generation](#auto-dependency-generation)
- [Separate Build Directory](#separate-build-directory)
- [Static Libraries](#static-libraries)
- [Shared Libraries](#shared-libraries)
- [Compiler Flag Management](#compiler-flag-management)
- [Multi-Binary Projects](#multi-binary-projects)
- [Testing Integration](#testing-integration)
- [Install and Uninstall](#install-and-uninstall)

## Canonical C Project Makefile

A complete, production-quality starting point:

```makefile
# Project
TARGET   := myprogram
SRCDIR   := src
BUILDDIR := build

# Toolchain
CC       ?= gcc
CFLAGS   := -Wall -Wextra -std=c11
CPPFLAGS := -Iinclude
LDFLAGS  :=
LDLIBS   :=

# Sources
SRCS := $(wildcard $(SRCDIR)/*.c)
OBJS := $(patsubst $(SRCDIR)/%.c,$(BUILDDIR)/%.o,$(SRCS))
DEPS := $(OBJS:.o=.d)

# Default target
all: $(BUILDDIR)/$(TARGET)

# Link
$(BUILDDIR)/$(TARGET): $(OBJS)
	$(CC) $(LDFLAGS) $^ $(LDLIBS) -o $@

# Compile
$(BUILDDIR)/%.o: $(SRCDIR)/%.c | $(BUILDDIR)
	$(CC) $(CPPFLAGS) $(CFLAGS) -MMD -MP -c $< -o $@

# Create build directory
$(BUILDDIR):
	mkdir -p $@

# Clean
.PHONY: all clean
.DELETE_ON_ERROR:

clean:
	rm -rf $(BUILDDIR)

# Dependencies
-include $(DEPS)
```

## Auto-Dependency Generation

### How it works
The compiler (`-MMD -MP`) generates `.d` files alongside `.o` files:

```makefile
# build/main.d (generated by gcc -MMD -MP):
build/main.o: src/main.c include/config.h include/util.h
include/config.h:
include/util.h:
```

- `-MMD`: Write dependency file for user headers (not system headers); `-MD` includes system headers
- `-MP`: Generate phony targets for headers (prevents errors when headers are deleted)

### Why -MP matters
Without `-MP`, deleting `include/util.h` causes:
```
make: *** No rule to make target 'include/util.h', needed by 'build/main.o'. Stop.
```

With `-MP`, the phony target `include/util.h:` satisfies make, and the compilation itself produces the real error message.

### Depfile in a different directory
```makefile
$(BUILDDIR)/%.o: $(SRCDIR)/%.c | $(BUILDDIR)
	$(CC) $(CPPFLAGS) $(CFLAGS) -MMD -MP -MF $(BUILDDIR)/$*.d -c $< -o $@
```

`-MF` explicitly sets the dependency file path.

## Separate Build Directory

### Flat build directory
```makefile
BUILDDIR := build
OBJS := $(addprefix $(BUILDDIR)/,$(notdir $(SRCS:.c=.o)))

# Need VPATH for source lookup:
vpath %.c $(sort $(dir $(SRCS)))

$(BUILDDIR)/%.o: %.c | $(BUILDDIR)
	$(CC) $(CPPFLAGS) $(CFLAGS) -MMD -MP -c $< -o $@
```

**Pitfall**: Flat build directories fail if two source files in different directories share the same name. Use mirrored structure instead.

### Mirrored build directory
```makefile
SRCS := $(shell find src -name '*.c')
OBJS := $(patsubst src/%.c,build/%.o,$(SRCS))
OBJDIRS := $(sort $(dir $(OBJS)))

$(OBJS): build/%.o: src/%.c | $(OBJDIRS)
	$(CC) $(CPPFLAGS) $(CFLAGS) -MMD -MP -c $< -o $@

$(OBJDIRS):
	mkdir -p $@
```

## Static Libraries

```makefile
LIBNAME := libutil
LIB_SRCS := $(wildcard lib/*.c)
LIB_OBJS := $(patsubst lib/%.c,build/lib/%.o,$(LIB_SRCS))

build/$(LIBNAME).a: $(LIB_OBJS)
	$(AR) rcs $@ $^

# Update only changed members (incremental):
build/$(LIBNAME).a: $(LIB_OBJS)
	$(AR) rcs $@ $?
```

The `$?` automatic variable (newer prerequisites) enables incremental archive updates.

### Archive member syntax
```makefile
# Build a single member:
lib.a(foo.o): foo.c
	$(CC) -c $< -o $%
	$(AR) r $@ $%
	rm $%
```

## Shared Libraries

### Linux (.so)
```makefile
CFLAGS += -fPIC

build/libutil.so: $(LIB_OBJS)
	$(CC) -shared -Wl,-soname,libutil.so.1 $^ -o $@

# Versioned:
build/libutil.so.1.0.0: $(LIB_OBJS)
	$(CC) -shared -Wl,-soname,libutil.so.1 $^ -o $@
	ln -sf libutil.so.1.0.0 build/libutil.so.1
	ln -sf libutil.so.1 build/libutil.so
```

### macOS (.dylib)
```makefile
CFLAGS += -fPIC

build/libutil.dylib: $(LIB_OBJS)
	$(CC) -dynamiclib -install_name @rpath/libutil.dylib $^ -o $@
```

### Cross-platform
```makefile
UNAME := $(shell uname -s)
ifeq ($(UNAME),Darwin)
  SHARED_EXT := .dylib
  SHARED_FLAGS := -dynamiclib
else
  SHARED_EXT := .so
  SHARED_FLAGS := -shared
endif

build/libutil$(SHARED_EXT): $(LIB_OBJS)
	$(CC) $(SHARED_FLAGS) $^ -o $@
```

## Compiler Flag Management

### Separating flag concerns
```makefile
# Base flags (always applied):
CFLAGS := -std=c11

# Warnings (strict):
CFLAGS += -Wall -Wextra -Wpedantic -Wshadow -Wconversion

# Optimization (configurable):
BUILD ?= debug

CFLAGS_debug   := -g -O0 -DDEBUG -fsanitize=address,undefined
LDFLAGS_debug  := -fsanitize=address,undefined
CFLAGS_release := -O2 -DNDEBUG -flto
LDFLAGS_release := -flto

CFLAGS  += $(CFLAGS_$(BUILD))
LDFLAGS += $(LDFLAGS_$(BUILD))
```

### Per-file flags
```makefile
# Target-specific variable:
build/generated.o: CFLAGS += -Wno-all

# Or pattern-specific:
build/vendor/%.o: CFLAGS := -w    # suppress all warnings for vendored code
```

### pkg-config integration
```makefile
PKGS := libcurl openssl zlib

CFLAGS  += $(shell pkg-config --cflags $(PKGS))
LDLIBS  += $(shell pkg-config --libs $(PKGS))
```

## Multi-Binary Projects

### Using eval+call template
```makefile
define binary-template
$(1)_SRCS := $$(wildcard src/$(1)/*.c)
$(1)_OBJS := $$(patsubst src/%.c,build/%.o,$$($(1)_SRCS))

build/$(1): $$($(1)_OBJS) build/libcommon.a
	$$(CC) $$(LDFLAGS) $$^ $$(LDLIBS) -o $$@

PROGRAMS += build/$(1)
endef

BINARIES := server client tool
$(foreach b,$(BINARIES),$(eval $(call binary-template,$(b))))

all: $(PROGRAMS)
```

### Shared common library
```makefile
COMMON_SRCS := $(wildcard src/common/*.c)
COMMON_OBJS := $(patsubst src/%.c,build/%.o,$(COMMON_SRCS))

build/libcommon.a: $(COMMON_OBJS)
	$(AR) rcs $@ $^

# Each binary links against it:
build/server: $(SERVER_OBJS) build/libcommon.a
build/client: $(CLIENT_OBJS) build/libcommon.a
```

## Testing Integration

```makefile
TEST_SRCS := $(wildcard tests/*.c)
TEST_BINS := $(patsubst tests/%.c,build/tests/%,$(TEST_SRCS))

# Link test binaries against project objects (minus main):
PROJECT_OBJS_NO_MAIN := $(filter-out build/main.o,$(OBJS))

build/tests/%: tests/%.c $(PROJECT_OBJS_NO_MAIN) | build/tests
	$(CC) $(CPPFLAGS) $(CFLAGS) $(LDFLAGS) $^ $(LDLIBS) -o $@

build/tests:
	mkdir -p $@

.PHONY: test
test: $(TEST_BINS)
	@for t in $^; do \
	  echo "Running $$t..."; \
	  $$t || exit 1; \
	done
	@echo "All tests passed."

# Or with a test runner:
test: $(TEST_BINS)
	@failed=0; \
	for t in $^; do \
	  if $$t; then echo "PASS: $$t"; \
	  else echo "FAIL: $$t"; failed=1; fi; \
	done; \
	exit $$failed
```

## Install and Uninstall

```makefile
PREFIX  ?= /usr/local
BINDIR  ?= $(PREFIX)/bin
LIBDIR  ?= $(PREFIX)/lib
INCDIR  ?= $(PREFIX)/include

.PHONY: install uninstall

install: $(BUILDDIR)/$(TARGET)
	install -d $(DESTDIR)$(BINDIR)
	install -m 755 $< $(DESTDIR)$(BINDIR)/

# For libraries:
install-lib: build/libutil.a build/libutil.so
	install -d $(DESTDIR)$(LIBDIR) $(DESTDIR)$(INCDIR)
	install -m 644 build/libutil.a $(DESTDIR)$(LIBDIR)/
	install -m 755 build/libutil.so $(DESTDIR)$(LIBDIR)/
	install -m 644 include/*.h $(DESTDIR)$(INCDIR)/

uninstall:
	rm -f $(DESTDIR)$(BINDIR)/$(TARGET)
```

`$(DESTDIR)` is the staging directory for package building â€” it's prepended to all paths but not compiled into the binary.
